using System;
using System.Globalization;
using System.Threading;

namespace Problem11.BinarySearch
{
    class BinarySearch
    {
        static void Main()
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            // Write a program that finds the index of given element in a sorted array of integers
            // by using the Binary search algorithm

            #region създаваме масив от числа
            int[] arr = { 6, 3, 1, 5, 2, 4 };
            //int[] arr = { 6, 3, 1, 5, 2, 4, 7 };
            //int[] arr = { -6, -3, -1, -5, -2, -4 };
            //int[] arr = { -6, 3, -1, 5, 0, 10 };
            #endregion

            // двоичното търсене работи върху сортирани масиви затова - сортираме
            Array.Sort(arr);

            // казваме какво търсим
            Console.Write("Enter the value to search: ");
            int searchValue = int.Parse(Console.ReadLine());

            // търсим...
            // идеята на двойчното търсене е да разделяме масива посредата и да срявняваме търсената стойност със средната в масива
            // и тъй като той е сортиран във възходящ ред лесно ще преценим коя половина ще отпадне и няма да се търси изобщо във нея
            // (ако е < ще се търси само в лявата половина, а ако е > само в дясната), това действие ще се повтаря докато не намерим
            // търсеният елемент или докато не се елеминират всички елементи от масива (т.е. търсената стойност не съществува)
            // по този начин съкращаваме значително времето за търсене

            // за да определим средата ни трябва начало и край на поредица
            // началото е първият индекс на масива
            int startIndex = 0;
            // краят е последния индекс на масива
            int endIndex = arr.Length - 1;
            // тъй като средата ще се пресмята за всяко сравнение първоначално ще е 0
            int middle = 0;

            // действието: намиране на средата и сравняването на стойността с търсената такава ще се повтаря докато не се елеминират 
            // всички стойности т.е. началото и края станат едно,еднакви
            while (startIndex <= endIndex)
            {
                // средата ще се пресмята като към началото се добавя половината от дължината така ще избегнем случаите на препълване 
                // на типа данни и ще си гарантираме точен резултат "no matter what"
                middle = startIndex + ((endIndex - startIndex) / 2);
                // вече сме сметнали средата ако е равна на търсената стойност спираме изпълнението на програмата и даваме индекса където е намерен резултата
                if (arr[middle] == searchValue)
                {
                    Console.WriteLine("Requested value is at index [{0}]", middle);
                    return;
                }
                // ако ли не, проверяваме дали стойността по средата е по-голяма от търсената и ако да изместваме края на сметната вече
                // среда минус 1(изваждаме 1 за да се движим в лявата половина, и да не използваме повторно тази стойност - вече я сравнявахме)
                else if (arr[middle] > searchValue)
                {
                    endIndex = middle - 1;
                }
                // иначе пък ще изместваме началото на сметната вече среда плюс 1(събираме с 1 за да се движим в дясната половина, и да не използваме повторно тази стойност - вече я сравнявахме)
                else
                {
                    startIndex = middle + 1;
                }
            }

            // ако цикълът приключи и средната стойност не е търсената значи тя не съществува и се извежда съответното съобщение
            // ако пък е намерена търсената ст-ст в цикъла този код няма да се изпълни
            if (middle != searchValue)
            {
                Console.WriteLine("The requested value does not exist in the specified array");
            }

        }
    }
}
