using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;

namespace Problem4.MaximalSequence
{
    class MaximalSequence
    {
        static void Main()
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            // Write a program that finds the maximal sequence of equal elements in an array

            // Примерни масиви за тестване
            //int[] arr1 = { 2, 1, 1, 2, 3, 3, 2, 2, 2, 1 };
            //int[] arr1 = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0 };
            //int[] arr1 = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1};
            int[] arr1 = { 1, 1, 1, 1, 0, 2, 2, 2, 2, 0, -3, -3, -3, -3, -3 };
            //int[] arr1 = { 0, 1, 2, 1, 2, 1, 1, 1, 1, 0 };
            //int[] arr1 = { 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 };

            // Логика: Минаваме през целия масив започвайки от позиция 1 за да можем да сравняваме предходната такава,
            // ако не са равни значи там започва нова поредица, а ако са равни значи това е продължение на текущата поредица

            // тук ще записваме индекса на началната позиция на новата поредица, който първоначално е 0, тъй като започваме от нулевият
            // индекс на масива
            int startIndex = 0;
            // тук ще записваме дължината на текущата поредица, която първоначално ще е 1, тъй като най-късата ни поредица е поне 1
            // елемент
            int length = 1;

            // създаваме си List от int-ове, използваме лист тъй като не знаем колко точно поредици ще открием за да създадем прост 
            // масив с фиксирана дължина.Тук ще записваме всички индекси които са начални позиции на поредица...
            List<int> startIndexes = new List<int>();

            // създаваме си List от int-ове, тук ще записваме дължината на текущата поредица
            List<int> lengths = new List<int>();

            // добавяме първият индекс-той винаги е част от поредица, макар и от един елемент
            startIndexes.Add(0);

            // минаваме по всички елементи на масива от позиция 1 до края 
            for (int i = 1; i < arr1.Length; i++)
            {
                // и сравняваме елементите ако са различни-имаме начало на нова поредица
                if (arr1[i] != arr1[i - 1])
                {
                    // съответно началния индекс на тази поредица е текущият индекс
                    startIndex = i;
                    // записваме го 
                    startIndexes.Add(startIndex);
                    // зписваме дължината на старата поредица и
                    lengths.Add(length);
                    // зануляваме дължината за да смятаме новата такава
                    length = 1;
                }
                // ако са еднакви-значи текущият индекс е продължение на вече започнала поредица и
                else
                {
                    // само увеличаваме дължината
                    length++;
                }

            }

            // накрая след излизане от цикъла трябва да добавим последната натрупана дължина тъй като цикъла е вече приключил, 
            // но последната дължина не е записана 
            lengths.Add(length);

            // следва да сглобим някъде всички поредици които имаме, тъй като за момента имаме само началните позиции на всяка от тях и 
            // съответната дължина, за целта създаваме масив от стрингове и там всеки елемент ще бъде отделна поредица от първоначалния 
            // масив "arr1" 

            string[] sequences = new string[startIndexes.Count];

            // минаваме по целия масив и 
            for (int i = 0; i < sequences.Length; i++)
            {
                // в една временна променлива записваме първия елемент от първата поредица  
                string nextSeq = "";
                // и го повтаряме колкото е дължината на съответната поредица тъй като елементите в нея са равни
                for (int j = 0; j < lengths[i]; j++)
                {
                    nextSeq += arr1[startIndexes[i]].ToString();
                }
                // след това записваме временната променлива в масива като пореден елемент
                sequences[i] = nextSeq;
            }

            // така вече имаме масив с всички поредици като отделни елементи, остава да намерим най-голямата поредица
            // най-голямата поредица е тази която има най-голяма дължина или в случай на равни дължини по-голяма стойност 
            // на елемента в нея

            // за да срявняваме ще приемем, че най-голямата дължина първоначално е 0
            int maxLength = 0;
            // тук ще записваме най-голямата поредица, първоначално тя е празна-не се знае коя е...
            string maxSequence = "";

            // минаваме по целият масив с поредиците и сравняваме 
            for (int i = 0; i < sequences.Length; i++)
            {
                // ако първият знак в поредицата е "-" значи поредицата е от отрицателни символи съответно ще има двойно повече 
                // символи понеже записваме готовите поредици като стринг
                if (sequences[i][0] == '-')
                {
                    // затова проверяваме дали половината от дължината на тази поредица е по-голяма от текущата най-голяма дължина и
                    // ако да най-голямата дължина става тази половина от дължината на текущата поредица, а тя самата става най-
                    // голямата поредица от еднакви елементи
                    if (sequences[i].Length / 2 > maxLength)
                    {
                        maxLength = sequences[i].Length / 2;
                        maxSequence = sequences[i];
                    }
                }
                // иначе ако дължината на текущата поредица е по-голяма от най-голямата дължина за момента, то най-голяма става 
                // дължината на текущата поредица и най-голяма поредица е текущата 
                else if (sequences[i].Length > maxLength)
                {
                    maxLength = sequences[i].Length;
                    maxSequence = sequences[i];
                }
                // иначе ако дължината на текущата поредица е равна на най-голямата дължина проверяваме 
                else if (sequences[i].Length == maxLength)
                {
                    // ако стойността на нулевия елемент в нея е по-голяма от стойността на нулевият елемент в най-голямата поредица 
                    // то най-голяма поредица става текущата (на нулевите елементи и в двете тъй като останалите елементи са равни)
                    if (sequences[i][0] > maxSequence[0])
                    {
                        maxSequence = sequences[i];
                    }
                }
            }
            
            // накрая отпечатваме резултата на конзолата
            Console.WriteLine("The maximal sequence is: {0} ({1} elements)", maxSequence, maxLength);
        }
    }
}
