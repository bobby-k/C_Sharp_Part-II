using System;
using System.Globalization;
using System.Threading;

namespace Problem6.MaximalKSum
{
    class MaximalKSum
    {
        static void Main()
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            // Write a program that reads two integer numbers N and K and an array of N elements from the console
            // Find in the array those K elements that have maximal sum

            // Логика: За да намерим тези К на брой елемента, които имат най-голям сбор, трябва да намерим най-големите К на брой
            // елемента в масива.Това ще стане като сортираме масива във възходящ ред, т.е. най-малкия елемент ще е на позиция 0
            // в масива, а най-големия ще е на последната позиция.Как ще стане това?!.Като вземем нулевият елемент и го сравним с 
            // останалите до края на масива.Най-малкият намерен записваме на позиция 0.После вземаме елемент 1 и го сравняваме с 
            // останалите до края на масива.Най-малкият намерен записваме на позиция 1.После вземаме елемент 2 и го сравняваме с 
            // останалите до края и т.н.След това просто ще изброим К на брой елемента в обратен ред, т.е. от последната позиция, 
            // К на брой елемента и това ще са най-големите такива.

            // изпълняваме първата част от условието вж.ред 13
            Console.Write("Enter value for N: ");
            int N = int.Parse(Console.ReadLine());
            Console.Write("Enter value for K: ");
            int K = int.Parse(Console.ReadLine());
            int[] arr1 = new int[N];

            Console.WriteLine("Enter {0} values for the array", N);
            for (int i = 0; i < arr1.Length; i++)
            {
                arr1[i] = int.Parse(Console.ReadLine());
            }

            // тук ще започнем със сортирането на масива, за целта приемаме, че първия елемент е най-малък и го сравняваме с останалите
            // ако намерим по-малък от него, тогава текущият елемент става най-малък, също така записваме и индекса му за да можем да го
            // разменим с елемента на позиция 0.И така ще проверяваме всички елементи и текущите най-малки такива ще ги поставяме в
            // началото разменяйки ги съответно с 0 позиция, после с 1, после с 2 и т.н.

            // това ще е първоначалния индекс на най-малкия елемент
            int smallestElementIndex = 0;
            // това ще е първоначалния най-малък елемент
            int smallestElement = arr1[smallestElementIndex];
            // чрез този индекс ще вземаме поредната позиция и ще я сравняваме с текущия най-малък елемент  
            int arr1Index = 1;
            // това е първоначалният индекс, който ще използваме за да разменяме стойността на елемента му с тази на най-малкия елемент
            int initialIndex = 0;

            while (arr1Index < arr1.Length)
            {
                // започваме от първия елемент(не от нулевия, тъй като приехме че той е най-малкия елемент за момента) и го сравняваме с
                // останалите до края.Така ще намерим най-малкия елемент от текущата поредица от елементи
                for (int i = arr1Index; i < arr1.Length; i++)
                {
                    // сравняваме с най-малкия елемент за момента,ако текущият елемент е по-малък, той става най-малкият такъв
                    // записваме и на кой индекс се намира
                    if (arr1[i] < smallestElement)
                    {
                        smallestElement = arr1[i];
                        smallestElementIndex = i;
                    }
                }

                // вече сме намерили най-малкия елемент и имаме индекса на позицията му, следва да го разменим с нулевата позиция,т.е.
                // да дойде най-напред, за целта записваме ст-та от нулевата позиция във временна променлива
                int temp = arr1[initialIndex];
                // след това записваме най-малкия елемент на нулевата позиция
                arr1[initialIndex] = arr1[smallestElementIndex];
                // и накрая на позицията където е най малкия елемент даваме ст-та на нулевата позиция, която записахме временно настрани
                arr1[smallestElementIndex] = temp;

                // вече имаме разменени ст-тите на нулева позиция и на най-малкия елемент,т.е. най-малкия е първи, следва да увеличим
                // ст-та на първоначалния индекс за да може при следващата размяна да запишем следващият по големина елемент като 
                // пореден
                initialIndex++;
                // продължаваме сравненията като за най-малък вземаме следващият елемент
                smallestElementIndex = initialIndex;
                smallestElement = arr1[smallestElementIndex];

                // увеличаваме за да вземем поредната позиция при сравняването на елементите
                arr1Index++;
            }

            // има и по-лесен начин, а именно използвайки вградената функционалност на .NET, така спестяваме писане на код
            // да се разкоментира ред 88 и да се закоментират редовете от 37 до 85  
            //Array.Sort(arr1);

            // следва да изведем на конзолата К на брой най-големи елемента
            Console.Write("The maximal {0} numbers are: ", K);

            // тук записваме последният индекс за да можем да го намаляваме к на брой пъти
            int nextIndex = arr1.Length - 1;

            for (int i = K; i > 0; i--)
            {
                // при всяка итерация ще се отпечатва пореден елемент отзад напред
                Console.Write(arr1[nextIndex] + " ");
                nextIndex--;
            }
            Console.WriteLine();

        }
    }
}
