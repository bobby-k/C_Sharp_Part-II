using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;

namespace Problem8.MaximalSum
{
    class MaximalSum
    {
        static void Main()
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            // Write a program that finds the sequence of maximal sum in a given array.

            // Примерни масиви за тестване
            int[] arr1 = { 2, 3, -6, -1, 2, -1, 6, 4, -8, 8 };
            //int[] arr1 = { -2, -3, -6, -1, -2, -1, -6, -4, -8, -8 };
            //int[] arr1 = { -2, 8, 1, -1, 0, -2, 1, -4, 8, -8 };
            //int[] arr1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            //int[] arr1 = { 10, 3, -8, 1, 0, 5, 4, 7, 2, 6, -9 };
            //int[] arr1 = { -10, -9, -8, -7, -6, -5, -4, -3, -2 };
            //int[] arr1 = { -10, -5, -4, -7, -1, 1, -6, -3, -2 };
            //int[] arr1 = { -10, -5, -4, 0, -1, 1, -6, -3, -2 };

            #region Вариант1 (разкоментирай редове 27-151 вкл.)
            //// тук ще трупаме текуща сума,която първоначално е само ст-та на нулевият елемент
            //int currentSum = arr1[0];
            //// тук ще записваме индексите за начало и край на поредицата с най-добра сума
            //int startIndex = 0;
            //int endIndex = 0;

            //#region Записване на индексите за начало и край на всички възможни поредици
            //List<int> startAndEndIndexes = new List<int>();

            //// добавяме първоначалният индекс
            //startAndEndIndexes.Add(startIndex);

            //for (int i = 0; i < arr1.Length; i++)
            //{
            //    for (int j = i + 1; j < arr1.Length; j++)
            //    {
            //        // към текущата сума добавяме ст-та на поредният елемент
            //        currentSum += arr1[j];
            //        // записваме текущата итерация на цикъла като индекс за край 
            //        endIndex = j;
            //        // добавяме го в листа
            //        startAndEndIndexes.Add(endIndex);
            //        // проверяваме ако индекса за край е равен на индекса на последният елемент в масива
            //        if (endIndex == arr1.Length - 1)
            //        {
            //            // увеличаваме индекса за начало тъй като значи,че започваме нова поредица от комбинации без най-левият елемент
            //            startIndex++;
            //        }
            //        // добавяме го в списъка
            //        startAndEndIndexes.Add(startIndex);
            //    }
            //    // при всяко излизане от вътрешният цикъл зануляваме текущата сума тъй като започваме нова поредица от комбинации без
            //    // най-левият елемент
            //    currentSum = 0;
            //}

            //// премахваме последният елемент в листа тъй като не ни е необходим и освобождаваме заделената памет която не се използва
            //startAndEndIndexes.RemoveAt(startAndEndIndexes.Count - 1);
            //startAndEndIndexes.TrimExcess();
            //#endregion

            //#region Сглобяване на всички поредици
            //List<int[]> allSequences = new List<int[]>();

            //// тук ще се определя дължината на всеки масив който ще записваме
            //int length = 2;
            //// максимален брой елементи в комбинация
            //int maxElementsInComb = arr1.Length;

            //// ще минаваме по индексите за начало, които са всеки втори от списъка
            //for (int i = 0; i < startAndEndIndexes.Count; i += 2)
            //{
            //    // ще записваме елементите на всяка комбинация в един временен масив
            //    int[] sequence = new int[length];
            //    // на всеки индекс за начало ще тръгва нов цикъл от това начало до съответният край
            //    int index = 0;
            //    for (int j = startAndEndIndexes[i]; j <= startAndEndIndexes[i + 1]; j++)
            //    {
            //        // и ще записва елемента от главния масив във временния, така на края на цикъла получаваме цялата комбинация
            //        sequence[index] = arr1[j];
            //        index++;
            //    }
            //    // добавяме я в списъка
            //    allSequences.Add(sequence);
            //    // увелияаваме дължината на следващият временен масив с един елемент
            //    length++;
            //    // проверяваме ако дължината е по-голяма от максималният брой елементи в комбинацията
            //    if (length > maxElementsInComb)
            //    {
            //        // зануляваме дължината(тя може да е най-малко два елемента за да има поредица)
            //        length = 2;
            //        // намаляваме макс. брой елементи с 1 тъй като при следващото завъртане на цикъла ще се ползва 1 елемент по-малко
            //        maxElementsInComb--;
            //    }
            //}

            //// освобождаваме заделената, но неизползвана памет
            //allSequences.TrimExcess();
            //#endregion

            //#region Намиране сумите на всяка поредица по отделно
            //List<int> allSums = new List<int>();

            //int sum = 0;

            //// за всяка поредица/комбинация която сме записали пускаме цикъл който да сумира всички елементи
            //foreach (int[] sequence in allSequences)
            //{
            //    for (int i = 0; i < sequence.Length; i++)
            //    {
            //        sum += sequence[i];
            //    }
            //    // записваме сумите като елементи в нов списък
            //    allSums.Add(sum);
            //    // зануляваме сумата
            //    sum = 0;
            //}

            //// накрая освобождаваме заделената но неупотребена памет
            //allSums.TrimExcess();
            //#endregion

            //#region Намиране на най-голямата сума

            //// тук ще записваме най-добрата намерена сума,като първоначалната и стойност няма да съвпада в никой случай с някой елемент
            //int bestSum = int.MinValue;

            //// минаваме по всички суми и търсим първата най-голяма
            //for (int i = 0; i < allSums.Count; i++)
            //{
            //    if (allSums[i] > bestSum)
            //    {
            //        bestSum = allSums[i];
            //    }
            //}
            //#endregion

            //#region Намиране на поредицата с най-голяма сума
            //// намираме най-голямата поредица като подаваме на вграденият в .NET метод IndexOf параметър най-голямата ни сума, така
            //// получаваме на кой индекс е тя и тъй като списъка със сумите и този с поредиците/комбинациите имат еднакви индекси
            //// намирайки индекса на най-голямата сума ние реално намираме и самата поредица
            //int bestSeqIndex = allSums.IndexOf(bestSum);
            //#endregion

            //Console.WriteLine("The sequence of maximal sum is: {0} --> {1}", string.Join(", ", allSequences[bestSeqIndex]), bestSum);
            #endregion

            #region Вариант2 по-кратък(разкоментирай редове 155-252 вкл.)
            // чрез този индекс ще указваме кой елемент да се зададе на текущата сума при "зануляване"
            int index = 0;
            int currentSum = arr1[index];
            // най-голямата сума първоначално е int.MinValue за да гарантираме че не съвпада с някой елемент с по-малка стойност
            int bestSum = int.MinValue;
            // тук ще записваме индексите за начало и край
            int startIndex = 0;
            int endIndex = 0;

            #region Намиране на най-голямата сума и последният индекс на поредицата за която се отнася тя
            // минаваме по елементите на целия масив за сравняваме всички възможни комбинации
            for (int i = 1; i < arr1.Length; i++)
            {
                // към текущата сума добавяме поредният елемент
                currentSum += arr1[i];
                // ако получената сума е по-голяма от най-голямата сума, то най-голяма става текущата
                // в такъв случай записваме и индекса за край на тази поредица за да можем да намерим началото й по-нататък
                if (currentSum > bestSum)
                {
                    bestSum = currentSum;
                    endIndex = i;
                }
                // допълнително проверяваме ако сме достигнали последният елемент на масива
                if (i == arr1.Length - 1)
                {
                    // увеличаваме индекса за да "занулим" така текущата сума, че тя да започва от следващият по ред елемент 
                    // понеже смятаме първо комбинациите с нулевия елемент,после с първият,после втория и т.н.
                    index++;
                    currentSum = arr1[index];
                    // зануляваме и брояча на цикъла така че да започва от този елемент от който тръгва текущата сума
                    // така си гарантираме че цикъла ще мине по всички възможни комбинации
                    i = index;
                }
            }
            #endregion

            #region Намиране на индекса за начало на най-голямата поредица/комбинация
            // ще използваме копие на стойността на най-голямата сума за да намерим индекса за начало на най-голямата поредица,като 
            // запазим и най-голямата сума непокътната за да я отпечатаме по-нататък.
            int bestSumCopy = bestSum;
            // ще бройм колко елемента сме минали.започваме от -1 за да не се брой елемента с крайният индекс, който вече имаме
            int count = -1;

            // ако най-голямата сума е равна на нула,ще събираме ст-тите на елементите от този с индекса за край докато получаваме нула
            if (bestSumCopy == 0)
            {
                // в такъв случай бройм от нула
                count = 0;
                // текущата сума ще започва от елемента с индекса за край
                int elementSum = arr1[endIndex];
                for (int i = endIndex - 1; i >= 0; i--)
                {
                    // ако текущата сума + ст-та на предходния елемент е 0,добавяме и бройм
                    if (elementSum + arr1[i] == 0)
                    {
                        elementSum += arr1[i];
                        count++;
                    }
                    // иначе спираме
                    else
                    {
                        break;
                    }
                }
            }
            // ако най-голямата сума е различна от нула,минаваме по елементите започвайки от този с индекс за край и изваждаме 
            // от най-голямата сума ст-та на предходният елемент докато получим 0
            else
            {
                // bestSumCopy > 0 --> за случаите в които най-голямата сума е положително число и bestSumCopy < 0 --> за случаите в 
                // които най-голямата сума е отрицателно число
                for (int i = endIndex; bestSumCopy > 0 || bestSumCopy < 0; i--)
                {
                    bestSumCopy -= arr1[i];
                    // бройм колко елемента сме минали
                    count++;
                }
            }

            // индекса за начало е индекса за край минус колкото елемента сме минали докато най-голямата сума стане 0
            startIndex = endIndex - count;
            #endregion

            // отпечатваме
            Console.Write("The sequence of maximal sum is: ");
            for (int i = startIndex; i <= endIndex; i++)
            {
                // това е за да се избегне отпечатването на запетаята след последният елемент
                if (i == endIndex)
                {
                    Console.Write(arr1[i]);
                }
                else
                {
                    Console.Write(arr1[i] + ", ");
                }
            }
            Console.WriteLine(" --> {0}", bestSum);
            #endregion
        }
    }
}
